
# 焼きなまし

点 = Junction　整数位置
木 = 現状の最小全域木、もしくは単純な木

- 1点追加する
- 1点削除する

削除は適当で良さそう

# 追加

どこに追加するか
    現状の木の次数が重要そう
        2の場合、点の場合は削除で良い
        3以上の場合、重心に移動する
        4以上の場合、2点選んで重心を追加すると良い場合がある
            追加した後、影響のある点をリストしてバネの原理で調整すると良さそう
    点の最小次数は3
        バッファがある方が良い場合は、その限りではない
    点は整数位置だが、小数でもって出力時に整数に直す

どうやって評価するか
    重要
    難しい
    結局のところ、点の作成に失敗する可能性があることが肝
        これをどうやって評価値に組み込むか
    最適な評価値は期待値か
        競技者間の勝数で競うスコアリングだから、冒険的な選択はマイナスになりうる
            冒険的という尺度は測りづらいから、あまり考えなくてよいか
            スコアリングが変わった
                勝利数ではなく、相対スコアが基準になった
                    期待値で問題なくなった
                    そんなに大きい変更ではない
        最適とする
        期待値を速く計算できるのか
            全状態を計算するのは無理
            点の追加しかたによって、木の変化量が変わってきて、ほぼ変化しない場合は簡単かもしれない
                連結した2辺に対して、重心に点を追加する場合はあまり変化しない
    普通に考えると、評価値のベースは全点が作成されたケースになるわけだが、maxFail=40%の時にかなり乖離する
        やっぱり期待値的なものは求めないとダメ
            failしないことを前提にした木で、failした時にどれくらい悪影響があるのか
        40%という閾値が低くて、考慮しなくて良い可能性は微妙にある

考えると点を追加することで距離が劇的に減少することはない
    三角形の重心に点を作って最大でもせいぜい15％減くらい
        その減算分で、点コストをペイする必要がある
    点は失敗しえるわけだから、バッファみたいな概念は一応ある
        その上で、単一点を追加する時に必ず点コストをペイしている必要があるのか
            仮に利得＝点コストの場合、バッファ分の利得があるから点は追加した方が良い
            利得=点コスト*0.99の場合、全ての点が作成されたとするとマイナスな訳だが、近くの点の作成に失敗していた時、プラスに働く可能性がある
        期待値をちゃんと計算すると、バッファという概念が織り込まれるから、それならそれで良い
            よって、利得が必ずしも点コストをペイしている必要はない
                期待値の計算は重そうだから、足切りは必要

最小全域木の高速化
    最初から計算する場合、プリム法がEに依存しなくて良くて良さそうか
    近傍の差分計算は要検討

点コスト、失敗無しのケースの最適解がベースになり得るかどうか
    なると仮定した時、大分簡単な問題になる
        かなり苦労してる
    反例を考えよう

点の作成が失敗しなかったとしても、1位のスコアに足りてない